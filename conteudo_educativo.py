CONTEUDOS = {
    "1": """
MÓDULO 1: PENSAMENTO LÓGICO DE PROGRAMAÇÃO

1.1 Introdução ao Pensamento Lógico

1.1.1 O que é lógica na programação

Definição: A lógica de programação é a organização coerente de instruções para resolver problemas específicos.
Contexto histórico: Evolução do pensamento lógico em computação desde Ada Lovelace e Alan Turing.
Aplicações: Como a lógica permeia todas as áreas de desenvolvimento de software.

1.1.2 Importância do raciocínio lógico para programadores

Eficiência na resolução de problemas: Permite criar soluções otimizadas com menos recursos.
Escalabilidade: Facilita o desenvolvimento de sistemas complexos a partir de componentes simples.
Manutenção: Código logicamente estruturado é mais fácil de entender e modificar.
Depuração: Identificação mais rápida de erros através de uma abordagem sistemática.

1.1.3 Como desenvolver habilidades de resolução de problemas

Prática deliberada: Exercícios progressivos de lógica e enigmas.
Análise de casos: Estudar soluções existentes e compreender sua lógica.
Pensamento computacional: Decomposição, reconhecimento de padrões, abstração e algoritmos.
Técnicas de brainstorming: Mapas mentais e diagramas para visualizar soluções.

1.2 Representação de Problemas

1.2.1 Decomposição de problemas complexos

Princípio "dividir para conquistar": Transformar problemas grandes em subproblemas gerenciáveis.
Técnicas de decomposição: Funcional, de dados, por requisitos e temporal.
Modularização: Criação de componentes independentes e reutilizáveis.
Exercícios: Decomposição de problemas cotidianos (ex: preparação de uma refeição, planejamento de viagem).

1.2.2 Análise e síntese de informações

Identificação de entradas e saídas: Definir claramente o que se tem e o que se deseja obter.
Restrições e limitações: Reconhecer os limites do problema e das soluções possíveis.
Organização de dados: Métodos para estruturar informações relevantes.
Técnicas de modelagem: Representações visuais de problemas (diagramas, mapas conceituais).

1.2.3 Identificação de padrões e relações

Reconhecimento de similaridades: Encontrar estruturas repetitivas ou análogas.
Generalização: Criar regras a partir de exemplos específicos.
Relações causais: Identificar conexões entre eventos, ações e resultados.
Exercícios: Jogos de reconhecimento de padrões e sequências lógicas.

1.3 Algoritmos

1.3.1 Definição e importância dos algoritmos

Conceito formal: Sequência finita e não ambígua de instruções para resolver um problema.
Características essenciais: Finitude, definição precisa, entrada/saída, efetividade.
Importância histórica: Algoritmos famosos e seu impacto na computação.
Algoritmos no cotidiano: Exemplos de processos algorítmicos em situações reais.

1.3.2 Características de um bom algoritmo

Correção: Resolução adequada do problema proposto.
Eficiência: Otimização de tempo e recursos.
Clareza: Facilidade de compreensão por humanos.
Generalidade: Capacidade de lidar com diferentes entradas.
Simplicidade: Preferência por soluções mais diretas quando possível.

1.3.3 Representações: pseudocódigo e fluxogramas

Pseudocódigo: Linguagem intermediária entre português e código de programação.
Regras e convenções: Padronização da escrita para maior clareza.
Fluxogramas: Símbolos padrão e sua interpretação.
Ferramentas: Aplicativos para criar pseudocódigo e fluxogramas.
Exercícios práticos: Tradução de problemas simples para ambas as representações.

1.4 Estruturas Lógicas Básicas

1.4.1 Sequência (comandos lineares)

Definição: Instruções executadas uma após a outra.
Ordem de execução: Importância da sequência correta de comandos.
Atribuição de valores: Como definir e modificar variáveis.
Exercícios: Construção de algoritmos lineares simples.

1.4.2 Seleção (condicionais)

Estrutura SE-ENTÃO-SENÃO: Tomada de decisões baseada em condições.
Condições simples e compostas: Uso de operadores lógicos para decisões complexas.
Aninhamento de condicionais: Estruturas de decisão dentro de outras.
Casos múltiplos (SWITCH/CASE): Alternativa para múltiplas condições.
Exercícios: Algoritmos com diferentes cenários de decisão.

1.4.3 Repetição (loops)

Estrutura ENQUANTO: Repetição com teste no início.
Estrutura REPITA-ATÉ: Repetição com teste no fim.
Estrutura PARA: Repetição com contador.
Loops infinitos e como evitá-los: Garantia de término.
Exercícios: Algoritmos com diferentes padrões de repetição.

1.5 Operadores Lógicos e Relacionais

1.5.1 Operadores lógicos (AND, OR, NOT)

Definição e símbolos: Representação em diferentes notações.
Prioridade de operações: Ordem de avaliação em expressões complexas.
Simplificação de expressões: Técnicas para reduzir complexidade.
Aplicações práticas: Uso em algoritmos de decisão.

1.5.2 Operadores relacionais (igual, diferente, maior que, etc.)

Conjunto completo: =, ≠, >, <, ≥, ≤.
Comparação entre diferentes tipos de dados: Números, texto, datas.
Precedência: Relação com operadores aritméticos e lógicos.
Exercícios: Avaliação de expressões relacionais.

1.5.3 Tabelas verdade e avaliação de expressões

Construção de tabelas verdade: Método sistemático para todas as combinações.
Avaliação de expressões complexas: Passo a passo em expressões com múltiplos operadores.
Leis da lógica booleana: Comutatividade, associatividade, distributividade.
Exercícios práticos: Construção e análise de tabelas verdade.
""",
    "2": """
MÓDULO 2: PROGRAMAÇÃO BÁSICA EM PYTHON

2.1 Introdução ao Python

2.1.1 História e filosofia da linguagem

Origens: Criação por Guido van Rossum e evolução ao longo do tempo.
Filosofia: O "Zen do Python" e seus princípios de design.
Características distintivas: Legibilidade, simplicidade e expressividade.
Comparação com outras linguagens: Vantagens e casos de uso.

2.1.2 Instalação e configuração do ambiente

Instalação do Python: Processo em diferentes sistemas operacionais.
Ambientes virtuais: Conceito e importância para gerenciamento de dependências.
IDE e editores: Opções populares (PyCharm, VS Code, IDLE).
Jupyter Notebook: Instalação e uso para aprendizado interativo.
Configuração do interpretador: Modos interativo e de script.

2.1.3 Primeiro programa: "Hello World"

Sintaxe básica: Estrutura de um programa Python.
Função print(): Exibição de mensagens na tela.
Comentários: Uso e boas práticas.
Execução: Diferentes formas de rodar um programa Python.
Exercício prático: Criação e execução do primeiro programa.

2.2 Variáveis e Tipos de Dados

2.2.1 Números (int, float)

Inteiros (int): Definição e operações básicas.
Ponto flutuante (float): Representação de números decimais.
Operadores aritméticos: +, -, *, /, //, %, **.
Precedência de operadores: Ordem de avaliação em expressões.
Funções matemáticas: Biblioteca math e operações comuns.
Exercícios: Cálculos matemáticos variados.

2.2.2 Strings

Definição: Sequências de caracteres.
Aspas simples e duplas: Diferenças e casos de uso.
Indexação e slicing: Acesso a caracteres e substrings.
Métodos de strings: upper(), lower(), split(), join(), etc.
Formatação: f-strings, format() e %-formatting.
Operações com strings: Concatenação, repetição, verificação.
Exercícios: Manipulação e formatação de texto.

2.2.3 Booleanos

Valores True e False: Conceito e representação.
Operações lógicas: and, or, not.
Expressões condicionais: Avaliação para verdadeiro ou falso.
Valores truthy e falsy: Comportamento de diferentes tipos em contexto booleano.
Exercícios: Avaliação de expressões lógicas.

2.2.4 Conversão entre tipos

Funções de conversão: int(), float(), str(), bool().
Conversões implícitas e explícitas: Quando ocorrem e como controlar.
Tratamento de erros: Lidando com conversões impossíveis.
Verificação de tipos: Função isinstance() e type().
Exercícios: Conversões entre diferentes tipos de dados.

2.3 Estruturas de Controle

2.3.1 Condicionais (if, elif, else)

Estrutura básica: Bloco if e indentação.
Condições múltiplas: Uso de elif para casos alternativos.
Bloco else: Tratamento do caso padrão.
Condicionais aninhados: Estruturas de decisão dentro de outras.
Operador ternário: Forma compacta para condicionais simples.
Exercícios: Implementação de algoritmos de decisão.

2.3.2 Loops (for, while)

Loop for: Iteração sobre sequências.
Função range(): Geração de sequências numéricas.
Loop while: Repetição baseada em condição.
Iteração sobre diferentes tipos de coleções: strings, listas, dicionários.
Controle de fluxo em loops: Indentação e blocos.
Exercícios: Implementação de diferentes padrões de repetição.

2.3.3 Comando break e continue

break: Interrupção total do loop.
continue: Pulo para a próxima iteração.
Uso de else com loops: Execução quando não há break.
Padrões comuns: Busca, validação, processamento condicional.
Exercícios: Controle avançado de fluxo em loops.

2.4 Estruturas de Dados

2.4.1 Listas

Definição e criação: Sintaxe e inicialização.
Acesso e modificação: Indexação e métodos.
Métodos comuns: append(), insert(), remove(), pop(), sort().
Slicing: Obtenção de sublistas.
Iteração: Percorrendo elementos.
List comprehensions: Criação concisa de listas.
Exercícios: Manipulação de dados em listas.

2.4.2 Tuplas

Definição e criação: Sintaxe e inicialização.
Imutabilidade: Diferenças em relação às listas.
Casos de uso: Quando preferir tuplas a listas.
Métodos e operações: count(), index(), desempacotamento.
Exercícios: Trabalho com dados imutáveis.

2.4.3 Dicionários

Definição e criação: Estrutura chave-valor.
Acesso e modificação: Uso de chaves e métodos.
Métodos comuns: keys(), values(), items(), get(), update().
Iteração: Percorrendo chaves, valores ou pares.
Dictionary comprehensions: Criação concisa de dicionários.
Exercícios: Gerenciamento de dados estruturados.

2.4.4 Conjuntos

Definição e criação: Coleções não ordenadas de elementos únicos.
Métodos e operações: add(), remove(), union(), intersection().
Propriedades matemáticas: União, interseção, diferença.
Casos de uso: Remoção de duplicatas, pertencimento.
Exercícios: Operações de conjunto em dados.

2.5 Funções

2.5.1 Definição e chamada

Sintaxe básica: Palavra-chave def e indentação.
Chamada de função: Passagem de argumentos.
Valor de retorno: Uso da palavra-chave return.
Funções sem retorno: Valor None.
Documentação: Docstrings e boas práticas.
Exercícios: Criação de funções simples.

2.5.2 Parâmetros e retornos

Parâmetros posicionais: Ordem de passagem.
Parâmetros nomeados: Especificação explícita.
Valores padrão: Definição de argumentos opcionais.
Número variável de argumentos: *args e **kwargs.
Múltiplos valores de retorno: Tuplas e desempacotamento.
Exercícios: Funções com diferentes padrões de parâmetros.

2.5.3 Escopo de variáveis

Escopo local e global: Visibilidade de variáveis.
Palavra-chave global: Acesso a variáveis externas.
Palavra-chave nonlocal: Acesso a variáveis de escopos intermediários.
Regra LEGB: Local, Enclosing, Global, Built-in.
Exercícios: Gerenciamento de escopo em funções.

2.5.4 Funções embutidas vs. personalizadas

Funções built-in: len(), max(), min(), sum(), etc.
Bibliotecas padrão: Módulos como math, random.
Quando criar funções personalizadas: Critérios e boas práticas.
Reusabilidade de código: Princípios de design.
Exercícios: Uso de funções embutidas e criação de personalizadas.

2.6 Módulos e Bibliotecas

2.6.1 Importação de módulos

Sintaxe de importação: import, from .import, as.
Módulos padrão: Visão geral da biblioteca padrão Python.
Criação de módulos: Organização de código em arquivos.
Pacotes: Estrutura de diretórios e __init__.py.
Exercícios: Importação e uso de módulos.

2.6.2 Bibliotecas padrão importantes

math: Funções e constantes matemáticas.
random: Geração de números aleatórios.
datetime: Manipulação de datas e horas.
collections: Estruturas de dados especializadas.
itertools: Ferramentas para iteração eficiente.
Exercícios: Uso prático de bibliotecas padrão.

2.6.3 Instalação de pacotes externos com pip

Gerenciador pip: Instalação e atualização.
PyPI (Python Package Index): Repositório de pacotes.
Requisitos e dependências: Arquivo requirements.txt.
Ambientes virtuais: Isolamento de dependências.
Bibliotecas populares: Breve introdução a pandas, numpy, matplotlib.
Exercícios: Instalação e uso básico de pacotes externos.

2.7 Projetos Práticos

2.7.1 Calculadora simples

Especificação: Funções para operações básicas.
Interface: Entrada via terminal ou GUI simples.
Tratamento de erros: Validação de entrada.
Extensões possíveis: Funções científicas, memória, histórico.
Desenvolvimento passo a passo: Guia de implementação.

2.7.2 Jogo de adivinhação

Regras do jogo: Geração de número aleatório e palpites.
Interface: Interação via terminal.
Lógica do jogo: Verificação de palpites e dicas.
Pontuação: Contagem de tentativas e recordes.
Extensões possíveis: Níveis de dificuldade, modos de jogo.
Desenvolvimento passo a passo: Guia de implementação.

2.7.3 Sistema de gerenciamento de tarefas

Funcionalidades: Adicionar, remover, listar e marcar tarefas.
Estrutura de dados: Organização das informações.
Interface: Comandos via terminal.
Persistência: Armazenamento em variáveis durante execução.
Extensões possíveis: Categorias, prioridades, datas.
Desenvolvimento passo a passo: Guia de implementação.
""",
    "3": """
MÓDULO 3: CIBERSEGURANÇA

3.1 Fundamentos de Cibersegurança

3.1.1 Importância e conceitos básicos

Definição de cibersegurança: Proteção de sistemas, redes e dados.
Cenário atual: Estatísticas e tendências de ataques.
Impactos de violações: Consequências financeiras, operacionais e reputacionais.
Atores e motivações: Hackers, hacktivistas, estados-nação, crime organizado.
Terminologia essencial: Vulnerabilidade, ameaça, risco, controle.

3.1.2 Pilares da segurança: confidencialidade, integridade e disponibilidade

Confidencialidade: Proteção contra acesso não autorizado.
Integridade: Garantia de precisão e confiabilidade dos dados.
Disponibilidade: Acesso contínuo a recursos e serviços.
Tríade CIA: Interdependência e equilíbrio entre os pilares.
Modelos de segurança: Ampliações da tríade (CIANA, Hexad).

3.1.3 Tipos de ameaças e vulnerabilidades

Malware: Vírus, worms, trojans, ransomware, spyware.
Engenharia social: Phishing, pretexting, baiting, scareware.
Ataques de rede: DoS/DDoS, man-in-the-middle, sniffer.
Ameaças internas: Funcionários, terceiros, erros humanos.
Vulnerabilidades comuns: OWASP Top 10, CVE, sistemas desatualizados.
Exercícios: Identificação de ameaças em cenários reais.

3.2 Segurança em Aplicações

3.2.1 Validação de entrada

Princípio de desconfiança: Toda entrada é potencialmente maliciosa.
Técnicas de validação: Sanitização, normalização, verificação de tipo.
Expressões regulares: Padrões para validação de entrada.
Validação no cliente vs. servidor: Importância da validação em camadas.
Exercícios: Implementação de funções de validação em Python.

3.2.2 Prevenção contra injeção de código

SQL Injection: Mecanismos e prevenção.
Command Injection: Riscos de execução de comandos do sistema.
Cross-Site Scripting (XSS): Tipos e métodos de prevenção.
Parametrização e prepared statements: Técnicas seguras.
Exercícios: Identificação e correção de vulnerabilidades de injeção.

3.2.3 Autenticação e autorização

Diferença entre autenticação e autorização: Conceitos e funções.
Métodos de autenticação: Senhas, biometria, tokens, MFA.
Gestão de sessões: Cookies, tokens, JWT.
Controle de acesso: RBAC, ABAC, lista de controle.
Boas práticas: Princípio do menor privilégio, separação de deveres.
Exercícios: Implementação de sistema de autenticação básico.

3.3 Criptografia Básica

3.3.1 Conceitos fundamentais

Definição de criptografia: Ciência de codificação segura.
Termos-chave: Texto plano, cifração, texto cifrado, chave.
Objetivos da criptografia: Confidencialidade, autenticidade, integridade.
História da criptografia: Da cifra de César aos algoritmos modernos.
Criptoanálise: Métodos de quebra de códigos.

3.3.2 Criptografia simétrica e assimétrica

Criptografia simétrica: Mesma chave para cifrar e decifrar.
Algoritmos simétricos: AES, 3DES, Blowfish.
Criptografia assimétrica: Par de chaves pública-privada.
Algoritmos assimétricos: RSA, ECC, DSA.
Comparação: Vantagens e desvantagens de cada abordagem.
Sistemas híbridos: Combinação de métodos para eficiência.

3.3.3 Implementação básica com Python

Biblioteca cryptography: Visão geral e instalação.
Funções hash: MD5, SHA, uso para verificação de integridade.
Cifração simétrica: Implementação com Fernet.
Assinaturas digitais: Verificação de autenticidade.
Boas práticas: Gerenciamento seguro de chaves.
Exercícios: Implementação de algoritmos criptográficos básicos.

3.4 Segurança de Redes

3.4.1 Fundamentos de redes

Modelo OSI: Camadas e vulnerabilidades associadas.
Protocolos comuns: TCP/IP, HTTP/HTTPS, DNS, SMTP.
Endereçamento IP: IPv4, IPv6, sub-redes.
Portas e serviços: Números padrão e propósitos.
Topologias de rede: Implicações de segurança.

3.4.2 Firewalls e sistemas de detecção de intrusão

Tipos de firewalls: Pacotes, aplicação, estado, próxima geração.
Regras de firewall: Configuração e manutenção.
Sistemas de Detecção de Intrusão (IDS): Baseados em rede e host.
Sistemas de Prevenção de Intrusão (IPS): Detecção e bloqueio.
Honeypots: Armadilhas para detecção de atacantes.
Exercícios: Configuração básica de regras de firewall.

3.4.3 Análise de tráfego com Python

Biblioteca Scapy: Captura e análise de pacotes.
Monitoramento de rede: Detecção de anomalias.
Filtros de pacotes: Seleção por protocolo, endereço, porta.
Análise de logs: Identificação de padrões suspeitos.
Visualização de dados: Representação gráfica de tráfego.
Exercícios: Implementação de monitor de rede simples.

3.5 Ética em Segurança

3.5.1 Testes de penetração éticos

Definição e objetivos: Simulação controlada de ataques.
Metodologias: OSSTMM, PTES, OWASP.
Fases de pentest: Reconhecimento, varredura, exploração, pós-exploração.
Escopo e autorização: Limites legais e contratuais.
Relatórios: Documentação e classificação de vulnerabilidades.

3.5.2 Divulgação responsável de vulnerabilidades

Processo de divulgação: Notificação, tempo de correção, publicação.
Programas de bug bounty: Plataformas e participação.
Divulgação completa vs. responsável: Debates éticos.
Coordenação com fabricantes: Protocolos de comunicação.
Estudo de caso: Exemplos de divulgações bem e mal-sucedidas.

3.5.3 Legislação de cibersegurança

Principais leis: LGPD (Brasil), GDPR (Europa), CCPA (EUA).
Crimes cibernéticos: Tipificação e penalidades.
Responsabilidade legal: Empresas, profissionais, usuários.
Conformidade: Requisitos regulatórios por setor.
Tendências legislativas: Evolução das leis de proteção de dados.

3.6 Práticas de Desenvolvimento Seguro

3.6.1 Princípios de OWASP

OWASP Top 10: Principais vulnerabilidades web.
Princípio da defesa em profundidade: Múltiplas camadas de proteção.
Princípio do privilégio mínimo: Acesso apenas ao necessário.
Falha segura: Comportamento previsível em caso de erro.
Segurança por design: Incorporação desde o início do desenvolvimento.

3.6.2 Gerenciamento seguro de senhas em Python

Algoritmos de hash seguros: bcrypt, Argon2, PBKDF2.
Salt e pepper: Proteção contra ataques de dicionário.
Biblioteca passlib: Implementação de hashing seguro.
Armazenamento de credenciais: Boas práticas.
Políticas de senha: Complexidade, rotação, recuperação.
Exercícios: Implementação de sistema de gerenciamento de senhas.

3.6.3 Auditoria de código

Revisão manual: Técnicas e checklists.
Ferramentas automatizadas: Analisadores estáticos.
Testes de segurança: Unitários, integração, penetração.
Gerenciamento de dependências: Verificação de vulnerabilidades.
Integração contínua: Automação de verificações de segurança.
Exercícios: Auditoria de código com ferramentas disponíveis.

3.7 Projeto Final

3.7.1 Análise de vulnerabilidades em uma aplicação simples

Especificação da aplicação: Funcionalidades e arquitetura.
Metodologia de análise: Abordagem sistemática.
Ferramentas de avaliação: Scanners de vulnerabilidade.
Técnicas de exploração manual: Identificação de falhas.
Documentação de vulnerabilidades: Formato e detalhamento.
Desenvolvimento passo a passo: Guia de implementação.

3.7.2 Implementação de medidas de segurança

Priorização de correções: Classificação por risco.
Mitigação vs. eliminação: Estratégias para diferentes vulnerabilidades.
Controles de segurança: Implementação em código.
Testes de verificação: Confirmação da eficácia das medidas.
Relatório final: Documentação técnica e executiva.
Desenvolvimento passo a passo: Guia de implementação.
""",
    "4": """
PRÁTICAS E AVALIAÇÕES

==============================
PENSAMENTO LÓGICO DE PROGRAMAÇÃO

1. Qual o valor final de x após executar o pseudocódigo abaixo?

x ← 5   
x ← x + 2   
x ← x * 3   

a) 21   b) 17   c) 15   d) 27   e) 7

2. Qual estrutura representa melhor a ideia de repetição?

a) if   b) elif   c) else   d) for   e) def

3. Qual das alternativas é um exemplo de condição lógica verdadeira?

a) 5 == 4   b) 3 > 5   c) 7 != 7   d) 2 < 3   e) 10 < 1

4. Em um algoritmo, o que o comando “se... então...” representa?

a) Laço de repetição   b) Entrada de dados   c) Desvio condicional   d) Saída de dados   e) Atribuição de variável

5. Quantas vezes o loop a seguir será executado?
para i de 1 até 5 faça   
   escreva(i)

a) 6   b) 5   c) 4   d) 0   e) 1

6. Em lógica, qual operador representa a negação?

a) &&   b) ||   c) ==   d) !   e) %

7. Qual é a saída do algoritmo abaixo?

x ← 10   
se x > 5 então   
    x ← x - 2 

a) 5   b) 10   c) 8   d) 2   e) 12

8. Em lógica, o que significa a tabela verdade do operador E (AND)?

a) True se uma for falsa   b) True se todas forem verdadeiras   c) False se ambas forem verdadeiras   d) Sempre false   e) True se uma for verdadeira

9. Um algoritmo pode ser definido como:

a) Uma ideia   b) Uma linguagem   c) Um conjunto de regras matemáticas   d) Uma sequência lógica de passos   e) Um software

10. Qual é a saída de print(2 + 2 * 2) em uma linguagem comum como Python?

a) 6   b) 8   c) 10   d) 12   e) 4

==============================
PROGRAMAÇÃO EM PYTHON

1. Como se declara uma função em Python?

a) function nomeFuncao():   b) def nomeFuncao():   c) function: nomeFuncao()   d) nomeFuncao define:   e) define nomeFuncao():

2. O que significa a função len()?

a) Soma os valores   b) Inverte uma string   c) Conta o número de itens   d) Concatena elementos   e) Cria uma lista

3. Qual é a saída do código abaixo?

print("2" + "3")

a) 5   b) 23   c) 6   d) Erro   e) 2 + 3

4. Qual estrutura representa um dicionário em Python?

a) []   b) ()   c) <>   d) {}   e) //

5. Qual dos comandos importa a biblioteca math?

a) import math   b) include math   c) using math   d) require math   e) math.load()

6. Qual é a saída do código?

x = [10, 20, 30]   
print(x[0])

a) 10   b) 20   c) 30   d) 0   e) Erro

7. Para que serve input() em Python?

a) Mostrar uma mensagem na tela   b) Sair do programa   c) Receber entrada do usuário   d) Executar um loop   e) Comparar valores

8. Qual dessas opções cria uma lista com os números de 0 a 4?

a) range(1,5)   b) list(5)   c) list(range(5))   d) [0..4]   e) generate(5)

9. Qual a saída?

a = True   
b = False   
print(a and b)

a) True   b) False   c) None   d) 0   e) Erro

10. O que o operador // faz em Python?

a) Soma   b) Potência   c) Módulo   d) Divisão inteira   e) Comentário

==============================
CIBERSEGURANÇA

1. O que é engenharia social?

a) Técnica de encriptação   b) Ataque a sistemas de hardware   c) Tentativa de manipular pessoas para obter dados   d) Proteção contra vírus   e) Um tipo de firewall

2. Qual item abaixo é um tipo de malware?

a) VPN   b) Ransomware   c) HTTPS   d) Criptografia   e) Backup

3. O que é autenticação de dois fatores (2FA)?

a) Duas senhas diferentes   b) Confirmação com dois dispositivos ao mesmo tempo   c) Verificação com dois elementos: senha e outro fator (código, biometria etc.)   d) Senha enviada por e-mail   e) Login por reconhecimento facial apenas

4. Qual dos itens abaixo ajuda a garantir a confidencialidade da informação?

a) Backup   b) Criptografia   c) Firewall   d) Engenharia social   e) VPN aberta

5. Qual dessas ameaças tenta se passar por um programa legítimo?

a) Ransomware   b) Worm   c) Trojan   d) Spyware   e) Rootkit

6. HTTPS é mais seguro que HTTP porque:

a) Usa conexão sem fio   b) Usa JavaScript   c) Utiliza criptografia SSL/TLS   d) Reduz o consumo de banda   e) Permite pop-ups

7. Qual prática é recomendada para senhas seguras?

a) Nome do usuário   b) Datas de aniversário   c) Frases longas com letras, números e símbolos   d) A mesma senha em todos os sites   e) Senhas simples que você lembra fácil

8. O que é um firewall?

a) Tipo de vírus   b) Proteção contra phishing   c) Sistema que bloqueia acessos não autorizados   d) Ferramenta de backup   e) Tipo de autenticação

9. O que o ataque de negação de serviço (DDoS) faz?

a) Rouba senhas   b) Cria backdoors   c) Inunda um servidor com tráfego para tirá-lo do ar   d) Remove arquivos   e) Copia banco de dados

10. Qual dos itens abaixo é uma prática insegura?

a) Usar 2FA   b) Atualizar software regularmente   c) Ignorar atualizações de segurança   d) Utilizar antivírus   e) Verificar remetente de e-mails

==============================
GABARITO

PENSAMENTO LÓGICO DE PROGRAMAÇÃO
1. a) 21
2. d) for
3. d) 2 < 3
4. c) Desvio condicional
5. b) 5
6. d) !
7. c) 8
8. b) True se todas forem verdadeiras
9. d) Uma sequência lógica de passos
10. a) 6

PROGRAMAÇÃO EM PYTHON
1. b) def nomeFuncao():
2. c) Conta o número de itens
3. b) 23
4. d) {}
5. a) import math
6. a) 10
7. c) Receber entrada do usuário
8. c) list(range(5))
9. b) False
10. d) Divisão inteira

CIBERSEGURANÇA
1. c) Tentativa de manipular pessoas para obter dados
2. b) Ransomware
3. c) Verificação com dois elementos
4. b) Criptografia
5. c) Trojan
6. c) Utiliza criptografia SSL/TLS
7. c) Frases longas com letras, números e símbolos
8. c) Sistema que bloqueia acessos não autorizados
9. c) Inunda um servidor com tráfego para tirá-lo do ar
10. c) Ignorar atualizações de segurança
"""
}
